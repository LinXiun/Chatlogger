--========================================================--
-- Chat Logger — Final Combined Script
-- Features:
--  - All, DM's, Me, Mentions (contains, case-insensitive), System, Friends, Individual player filters
--  - TextChatService + legacy Player.Chatted fallback (detects /w, /whisper)
--  - Copy-to-clipboard, spectate, triple-click teleport
--  - New message indicator, UTC+8 timestamps, per-username color hashing
--  - Top-right fading notifications for incoming whispers (stacked)
--  - Dynamic player list in dropdown
--  - Message cap for performance
--  - Preserves all prior behavior
--========================================================--

local Players = game:GetService("Players")
local TextChatService = game:GetService("TextChatService")
local TweenService = game:GetService("TweenService")
local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")

-- Prevent multiple instances
if PlayerGui:FindFirstChild("ChatLoggerGui") then
    return
end

-- CONFIG
local MESSAGE_CAP = 1500 -- maximum messages to store before trimming
local NOTIFY_FADE_IN = 0.25
local NOTIFY_DISPLAY = 2
local NOTIFY_FADE_OUT = 0.5
local NOTIFY_MARGIN = 8
local TIMESTAMP_UTC_OFFSET = 8 -- UTC+8

-- Utility: Safe clipboard
local function setClipboardSafe(text)
    pcall(function()
        if setclipboard then
            setclipboard(text)
        elseif toclipboard then
            toclipboard(text)
        end
    end)
end

-- UI Setup
local gui = Instance.new("ScreenGui")
gui.Name = "ChatLoggerGui"
gui.ResetOnSpawn = false
gui.IgnoreGuiInset = true
gui.Parent = PlayerGui

-- Main Frame
local mainFrame = Instance.new("Frame")
mainFrame.Name = "MainFrame"
mainFrame.Size = UDim2.new(0, 360, 0, 320)
mainFrame.Position = UDim2.new(0, 10, 0, 10)
mainFrame.BackgroundColor3 = Color3.fromRGB(20,20,20)
mainFrame.BorderSizePixel = 0
mainFrame.Active = true
mainFrame.Draggable = true
mainFrame.Parent = gui

-- Header
local header = Instance.new("Frame")
header.Name = "Header"
header.Size = UDim2.new(1,0,0,28)
header.BackgroundColor3 = Color3.fromRGB(30,30,30)
header.BorderSizePixel = 0
header.Parent = mainFrame

local title = Instance.new("TextLabel")
title.Name = "Title"
title.Text = "Chat Logger"
title.Font = Enum.Font.SourceSansBold
title.TextSize = 16
title.TextColor3 = Color3.fromRGB(255,255,255)
title.BackgroundTransparency = 1
title.Position = UDim2.new(0,8,0,0)
title.Size = UDim2.new(0,140,1,0)
title.Parent = header

-- Header Buttons
local returnButton = Instance.new("TextButton")
returnButton.Name = "ReturnButton"
returnButton.Size = UDim2.new(0,40,1,0)
returnButton.Position = UDim2.new(1,-120,0,0)
returnButton.Text = "↺"
returnButton.Font = Enum.Font.SourceSansBold
returnButton.TextColor3 = Color3.new(1,1,1)
returnButton.TextSize = 20
returnButton.BackgroundColor3 = Color3.fromRGB(50,50,50)
returnButton.BorderSizePixel = 0
returnButton.Parent = header

local dropdownButton = Instance.new("TextButton")
dropdownButton.Name = "DropdownButton"
dropdownButton.Size = UDim2.new(0,40,1,0)
dropdownButton.Position = UDim2.new(1,-80,0,0)
dropdownButton.Text = "%"
dropdownButton.Font = Enum.Font.SourceSansBold
dropdownButton.TextColor3 = Color3.new(1,1,1)
dropdownButton.TextSize = 20
dropdownButton.BackgroundColor3 = Color3.fromRGB(50,50,50)
dropdownButton.BorderSizePixel = 0
dropdownButton.Parent = header

local hideButton = Instance.new("TextButton")
hideButton.Name = "HideButton"
hideButton.Size = UDim2.new(0,40,1,0)
hideButton.Position = UDim2.new(1,-40,0,0)
hideButton.Text = "v"
hideButton.Font = Enum.Font.SourceSansBold
hideButton.TextColor3 = Color3.new(1,1,1)
hideButton.TextSize = 20
hideButton.BackgroundColor3 = Color3.fromRGB(50,50,50)
hideButton.BorderSizePixel = 0
hideButton.Parent = header

local unhideButton = Instance.new("TextButton")
unhideButton.Name = "UnhideButton"
unhideButton.Size = UDim2.new(0,40,0,40)
unhideButton.Position = UDim2.new(0,10,0,10)
unhideButton.Text = "^"
unhideButton.Font = Enum.Font.SourceSansBold
unhideButton.TextColor3 = Color3.new(1,1,1)
unhideButton.TextSize = 22
unhideButton.BackgroundColor3 = Color3.fromRGB(50,50,50)
unhideButton.BorderSizePixel = 0
unhideButton.Visible = false
unhideButton.Parent = gui

-- Dropdown frame
local dropdownFrame = Instance.new("Frame")
dropdownFrame.Name = "DropdownFrame"
dropdownFrame.Size = UDim2.new(0,160,0,0)
dropdownFrame.Position = UDim2.new(0,0,0,28)
dropdownFrame.BackgroundColor3 = Color3.fromRGB(35,35,35)
dropdownFrame.BorderSizePixel = 0
dropdownFrame.ClipsDescendants = true
dropdownFrame.Parent = mainFrame

local dropdownLayout = Instance.new("UIListLayout")
dropdownLayout.SortOrder = Enum.SortOrder.LayoutOrder
dropdownLayout.Parent = dropdownFrame

-- Add static buttons (All, DM's, Me, Mentions, System, Friends)
local function makeDropdownButton(text)
    local btn = Instance.new("TextButton")
    btn.Size = UDim2.new(1,0,0,26)
    btn.Text = text
    btn.BackgroundColor3 = Color3.fromRGB(50,50,50)
    btn.TextColor3 = Color3.new(1,1,1)
    btn.Font = Enum.Font.SourceSansBold
    btn.TextSize = 14
    btn.BorderSizePixel = 0
    btn.Parent = dropdownFrame
    return btn
end

local allButton = makeDropdownButton("All")
local dmButton = makeDropdownButton("DM's")
local meButton = makeDropdownButton("Me")
local mentionsButton = makeDropdownButton("Mentions")
local systemButton = makeDropdownButton("System")
local friendsButton = makeDropdownButton("Friends")

-- Separator label for dynamic player list
local playersLabel = Instance.new("TextLabel")
playersLabel.Size = UDim2.new(1,0,0,20)
playersLabel.Text = "Players"
playersLabel.Font = Enum.Font.SourceSansBold
playersLabel.TextSize = 13
playersLabel.TextColor3 = Color3.new(1,1,1)
playersLabel.BackgroundTransparency = 1
playersLabel.Parent = dropdownFrame

-- dynamic list will be populated below

-- Message scrolling frame
local messageFrame = Instance.new("ScrollingFrame")
messageFrame.Name = "MessageFrame"
messageFrame.Size = UDim2.new(1,0,1, -28)
messageFrame.Position = UDim2.new(0,0,0,28)
messageFrame.BackgroundColor3 = Color3.fromRGB(25,25,25)
messageFrame.ScrollBarThickness = 6
messageFrame.CanvasSize = UDim2.new(0,0,0,0)
messageFrame.BorderSizePixel = 0
messageFrame.Parent = mainFrame

local msgLayout = Instance.new("UIListLayout")
msgLayout.SortOrder = Enum.SortOrder.LayoutOrder
msgLayout.Parent = messageFrame

-- New message button indicator
local newMsgButton = Instance.new("TextButton")
newMsgButton.Size = UDim2.new(1,0,0,26)
newMsgButton.Position = UDim2.new(0,0,1,-26)
newMsgButton.Text = "New messages below ↓"
newMsgButton.Font = Enum.Font.SourceSansBold
newMsgButton.TextSize = 14
newMsgButton.BackgroundColor3 = Color3.fromRGB(60,60,60)
newMsgButton.TextColor3 = Color3.new(1,1,1)
newMsgButton.Visible = false
newMsgButton.Parent = mainFrame

-- Notification container (top-right)
local notifyContainer = Instance.new("Frame")
notifyContainer.Name = "NotificationContainer"
notifyContainer.Size = UDim2.new(0, 220, 0, 0) -- height will grow with contents
notifyContainer.Position = UDim2.new(1, -10, 0, 10)
notifyContainer.AnchorPoint = Vector2.new(1,0)
notifyContainer.BackgroundTransparency = 1
notifyContainer.Parent = gui

local notifyLayout = Instance.new("UIListLayout")
notifyLayout.SortOrder = Enum.SortOrder.LayoutOrder
notifyLayout.VerticalAlignment = Enum.VerticalAlignment.Top
notifyLayout.Padding = UDim.new(0, NOTIFY_MARGIN)
notifyLayout.Parent = notifyContainer

-- Internal State
local messages = {}
local currentFilter = "All" -- "All", "DM", "Me", "Mentions", "System", "Friends", or number (userId)
local dropdownOpen = false
local playerButtons = {} -- map userId -> button

-- Utilities
local function hashColor(name)
    local h = 0
    for i = 1, #name do
        h = (h + name:byte(i)) % 360
    end
    return Color3.fromHSV(h/360, 0.6, 1)
end

local function timestamp()
    local t = os.date("!*t")
    t.hour = t.hour + TIMESTAMP_UTC_OFFSET
    while t.hour >= 24 do t.hour = t.hour - 24 end
    local ampm = t.hour >= 12 and "PM" or "AM"
    local hour = t.hour % 12
    if hour == 0 then hour = 12 end
    return string.format("%02d:%02d %s", hour, t.min, ampm)
end

local function clampMessages()
    if #messages > MESSAGE_CAP then
        local removeCount = #messages - MESSAGE_CAP
        for i=1, removeCount do
            table.remove(messages, 1)
        end
    end
end

local function updateCanvas()
    task.defer(function()
        messageFrame.CanvasSize = UDim2.new(0,0,0,msgLayout.AbsoluteContentSize.Y)
    end)
end

-- Notification: show a fading notification for incoming whispers
local function showWhisperNotification(senderDisplay)
    local notif = Instance.new("Frame")
    notif.Size = UDim2.new(1, 0, 0, 36)
    notif.BackgroundColor3 = Color3.fromRGB(25,25,25)
    notif.BorderSizePixel = 0
    notif.BackgroundTransparency = 1
    notif.Parent = notifyContainer

    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0,6)
    corner.Parent = notif

    local txt = Instance.new("TextLabel")
    txt.Size = UDim2.new(1, -12, 1, 0)
    txt.Position = UDim2.new(0, 6, 0, 0)
    txt.BackgroundTransparency = 1
    txt.Font = Enum.Font.SourceSansBold
    txt.TextSize = 14
    txt.TextColor3 = Color3.fromRGB(240,240,240)
    txt.TextXAlignment = Enum.TextXAlignment.Left
    txt.Text = "Whisper from "..tostring(senderDisplay)
    txt.TextTransparency = 1
    txt.Parent = notif

    -- Fade in
    TweenService:Create(notif, TweenInfo.new(NOTIFY_FADE_IN), {BackgroundTransparency = 0.12}):Play()
    TweenService:Create(txt, TweenInfo.new(NOTIFY_FADE_IN), {TextTransparency = 0}):Play()

    -- Schedule fade out and destroy
    task.delay(NOTIFY_FADE_IN + NOTIFY_DISPLAY, function()
        TweenService:Create(notif, TweenInfo.new(NOTIFY_FADE_OUT), {BackgroundTransparency = 1}):Play()
        TweenService:Create(txt, TweenInfo.new(NOTIFY_FADE_OUT), {TextTransparency = 1}):Play()
        task.delay(NOTIFY_FADE_OUT + 0.05, function()
            if notif and notif.Parent then
                notif:Destroy()
            end
        end)
    end)
end

-- Render logic
local function makeMessageEntry(msg)
    local item = Instance.new("Frame")
    item.Size = UDim2.new(1, -6, 0, 44)
    item.BackgroundTransparency = 1
    item.BorderSizePixel = 0
    item.Parent = messageFrame

    local nameBtn = Instance.new("TextButton")
    nameBtn.Size = UDim2.new(0, 140, 1, 0)
    nameBtn.Position = UDim2.new(0, 6, 0, 0)
    nameBtn.Text = msg.DisplayName or msg.Name
    nameBtn.TextColor3 = hashColor(msg.Name or "")
    nameBtn.Font = Enum.Font.SourceSansBold
    nameBtn.TextSize = 14
    nameBtn.TextXAlignment = Enum.TextXAlignment.Left
    nameBtn.BackgroundTransparency = 1
    nameBtn.BorderSizePixel = 0
    nameBtn.Parent = item

    local timeLabel = Instance.new("TextLabel")
    timeLabel.Size = UDim2.new(0, 80, 1, 0)
    timeLabel.Position = UDim2.new(0, 150, 0, 0)
    timeLabel.Text = msg.Time or ""
    timeLabel.TextColor3 = Color3.fromRGB(200,200,200)
    timeLabel.Font = Enum.Font.SourceSans
    timeLabel.TextSize = 13
    timeLabel.BackgroundTransparency = 1
    timeLabel.Parent = item

    local msgBtn = Instance.new("TextButton")
    msgBtn.Size = UDim2.new(1, -236, 1, 0)
    msgBtn.Position = UDim2.new(0, 236, 0, 0)
    msgBtn.Text = msg.Text or ""
    msgBtn.TextWrapped = true
    msgBtn.TextColor3 = Color3.fromRGB(220,220,220)
    msgBtn.TextXAlignment = Enum.TextXAlignment.Left
    msgBtn.Font = Enum.Font.SourceSans
    msgBtn.TextSize = 14
    msgBtn.BackgroundTransparency = 1
    msgBtn.BorderSizePixel = 0
    msgBtn.Parent = item

    -- Click: spectate on single click, triple-click to teleport
    do
        local clickCount = 0
        local lastClick = 0
        nameBtn.MouseButton1Click:Connect(function()
            local now = tick()
            if now - lastClick > 0.8 then
                clickCount = 0
            end
            clickCount = clickCount + 1
            lastClick = now

            -- single click: spectate
            if clickCount == 1 then
                -- spectate after a short delay so triple-click can be detected
                task.delay(0.2, function()
                    if clickCount == 1 then
                        local target = Players:GetPlayerByUserId(msg.FromUserId or 0)
                        if target and target.Character and target.Character:FindFirstChild("Humanoid") then
                            workspace.CurrentCamera.CameraSubject = target.Character:FindFirstChild("Humanoid")
                        end
                    end
                    -- reset if time passed
                    if tick() - lastClick > 0.8 then
                        clickCount = 0
                    end
                end)
            end

            -- triple click: teleport local player to target if possible
            if clickCount >= 3 then
                local target = Players:GetPlayerByUserId(msg.FromUserId or 0)
                if target and target.Character and target.Character:FindFirstChild("HumanoidRootPart") and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    local hrp = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                    local targetHRP = target.Character:FindFirstChild("HumanoidRootPart")
                    -- teleport
                    hrp.CFrame = targetHRP.CFrame + Vector3.new(0,3,0)
                end
                clickCount = 0
            end
        end)
    end

    -- Copy message to clipboard on message button click
    msgBtn.MouseButton1Click:Connect(function()
        setClipboardSafe(msg.Text or "")
        -- flash feedback (brief color change)
        local oldColor = msgBtn.TextColor3
        msgBtn.TextColor3 = Color3.fromRGB(120,255,120)
        task.delay(0.5, function()
            if msgBtn and msgBtn.Parent then
                msgBtn.TextColor3 = oldColor
            end
        end)
    end)

    return item
end

local function renderMessages()
    -- Clear current rendered entries
    for _, c in ipairs(messageFrame:GetChildren()) do
        if c:IsA("Frame") then
            c:Destroy()
        end
    end

    -- Iterate messages and apply filter
    for _, msg in ipairs(messages) do
        -- filter logic
        if currentFilter == "DM" then
            if not msg.IsWhisper then
                goto continue
            end
            if msg.ToUserId ~= LocalPlayer.UserId then
                goto continue
            end
        elseif currentFilter == "Me" then
            if msg.FromUserId ~= LocalPlayer.UserId then
                goto continue
            end
        elseif currentFilter == "Mentions" then
            local txt = tostring(msg.Text or "")
            local lower = string.lower(txt)
            local uname = string.lower(LocalPlayer.Name or "")
            local disp = string.lower(LocalPlayer.DisplayName or "")
            if not (string.find(lower, uname, 1, true) or string.find(lower, disp, 1, true) or string.find(lower, "@"..uname, 1, true) or string.find(lower, "@"..disp, 1, true)) then
                goto continue
            end
        elseif currentFilter == "System" then
            if not msg.IsSystem then
                goto continue
            end
        elseif currentFilter == "Friends" then
            if not msg.FromUserId or not LocalPlayer:IsFriendsWith(msg.FromUserId) then
                goto continue
            end
        elseif type(currentFilter) == "number" then
            if msg.FromUserId ~= currentFilter then
                goto continue
            end
        end

        -- Render
        makeMessageEntry(msg)

        ::continue::
    end

    updateCanvas()
end

-- Add a message to memory + render & new message indicator
local function addMessage(data)
    table.insert(messages, data)
    clampMessages()
    -- Auto-render
    renderMessages()

    -- Determine whether user is scrolled to bottom
    local viewSize = messageFrame.AbsoluteWindowSize.Y
    local contentSize = msgLayout.AbsoluteContentSize.Y
    local canvasPos = messageFrame.CanvasPosition.Y
    local maxPos = math.max(0, contentSize - viewSize)

    if canvasPos < maxPos - 20 then
        newMsgButton.Visible = true
    else
        -- auto scroll to bottom
        messageFrame.CanvasPosition = Vector2.new(0, contentSize)
        newMsgButton.Visible = false
    end
end

-- Player list population
local function rebuildPlayerButtons()
    -- Remove existing player buttons
    for _, btn in pairs(playerButtons) do
        if btn and btn.Parent then
            btn:Destroy()
        end
    end
    playerButtons = {}

    -- For each player, create a button
    local sorted = {}
    for _, p in ipairs(Players:GetPlayers()) do
        table.insert(sorted, p)
    end
    table.sort(sorted, function(a,b) return string.lower(a.Name) < string.lower(b.Name) end)
    for _, p in ipairs(sorted) do
        if p ~= LocalPlayer then
            local b = makeDropdownButton(p.DisplayName .. " (" .. p.Name .. ")")
            b.LayoutOrder = p.UserId
            b.MouseButton1Click:Connect(function()
                currentFilter = p.UserId
                renderMessages()
            end)
            playerButtons[p.UserId] = b
        end
    end
end

-- Hook player join/leave to rebuild list
Players.PlayerAdded:Connect(function()
    rebuildPlayerButtons()
end)
Players.PlayerRemoving:Connect(function()
    rebuildPlayerButtons()
end)
-- initial build
rebuildPlayerButtons()

-- Capture TextChatService messages (modern chat)
if TextChatService and TextChatService.MessageReceived then
    TextChatService.MessageReceived:Connect(function(msg)
        -- msg.TextSource might be nil for system messages
        local isSystem = not msg.TextSource
        local isWhisper = (msg.ChatMessageType == Enum.TextChatMessageType.Whisper)
        local fromUserId = nil
        local fromName = "System"
        local fromDisplay = "System"
        if msg.TextSource then
            fromUserId = msg.TextSource.UserId
            fromName = msg.TextSource.Name
            fromDisplay = msg.TextSource.DisplayName or msg.TextSource.Name
        end

        local toUserId = nil
        if msg.Recipient then
            toUserId = msg.Recipient.UserId
        end

        local entry = {
            Name = fromName,
            DisplayName = fromDisplay,
            Text = msg.Text,
            Time = timestamp(),
            FromUserId = fromUserId,
            ToUserId = toUserId,
            IsWhisper = isWhisper,
            IsSystem = isSystem
        }

        addMessage(entry)

        -- Whisper incoming notification
        if isWhisper and toUserId == LocalPlayer.UserId and fromUserId ~= LocalPlayer.UserId then
            showWhisperNotification(entry.DisplayName or entry.Name)
        end
    end)
end

-- Legacy fallback: Player.Chatted
-- We'll try to parse outgoing/incoming /w or /whisper commands
Players.PlayerAdded:Connect(function(p)
    p.Chatted:Connect(function(msg)
        if not msg then return end

        local lower = string.lower(msg)
        local isWhisper = false
        local fromUserId = p.UserId
        local fromName = p.Name
        local fromDisplay = p.DisplayName or p.Name
        local toUserId = nil
        local textOnly = msg

        -- Detect "/w target message" or "/whisper target message"
        local wprefix, target, rest = string.match(msg, "^%s*/([wW]|whisper)%s+(%S+)%s+(.+)")
        if wprefix and target and rest then
            isWhisper = true
            textOnly = rest
            -- try to find target player
            local targetPlayer = Players:FindFirstChild(target) or Players:FindFirstChild(string.gsub(target, "^@", ""))
            if not targetPlayer then
                -- try case-insensitive
                for _, candidate in ipairs(Players:GetPlayers()) do
                    if string.lower(candidate.Name) == string.lower(target) or string.lower(candidate.DisplayName or "") == string.lower(target) then
                        targetPlayer = candidate
                        break
                    end
                end
            end
            if targetPlayer then
                toUserId = targetPlayer.UserId
            end
        else
            -- also detect "target, message" style? skip — keep simple
            isWhisper = false
            textOnly = msg
        end

        -- For some games, system messages may be printed as chat via nil source; we skip that here
        local entry = {
            Name = fromName,
            DisplayName = fromDisplay,
            Text = textOnly,
            Time = timestamp(),
            FromUserId = fromUserId,
            ToUserId = toUserId,
            IsWhisper = isWhisper,
            IsSystem = false
        }

        addMessage(entry)

        -- Whisper incoming notify: if this message is a whisper and it targets local player and the sender is not localplayer
        if isWhisper and toUserId == LocalPlayer.UserId and fromUserId ~= LocalPlayer.UserId then
            showWhisperNotification(entry.DisplayName or entry.Name)
        end
    end)
end)

-- Additionally, capture local player's own chat via LocalPlayer.Chatted (outgoing messages)
LocalPlayer.Chatted:Connect(function(msg)
    if not msg then return end
    local lower = string.lower(msg)
    local isWhisper = false
    local toUserId = nil
    local textOnly = msg

    local wprefix, target, rest = string.match(msg, "^%s*/([wW]|whisper)%s+(%S+)%s+(.+)")
    if wprefix and target and rest then
        isWhisper = true
        textOnly = rest
        -- try to resolve target
        local targetPlayer = Players:FindFirstChild(target) or Players:FindFirstChild(string.gsub(target, "^@", ""))
        if not targetPlayer then
            for _, candidate in ipairs(Players:GetPlayers()) do
                if string.lower(candidate.Name) == string.lower(target) or string.lower(candidate.DisplayName or "") == string.lower(target) then
                    targetPlayer = candidate
                    break
                end
            end
        end
        if targetPlayer then
            toUserId = targetPlayer.UserId
        end
    end

    local entry = {
        Name = LocalPlayer.Name,
        DisplayName = LocalPlayer.DisplayName or LocalPlayer.Name,
        Text = textOnly,
        Time = timestamp(),
        FromUserId = LocalPlayer.UserId,
        ToUserId = toUserId,
        IsWhisper = isWhisper,
        IsSystem = false
    }

    addMessage(entry)
end)

-- Dropdown button hooks
dropdownButton.MouseButton1Click:Connect(function()
    dropdownOpen = not dropdownOpen
    local targetSize = dropdownOpen and UDim2.new(0,160,0, dropdownLayout.AbsoluteContentSize.Y + 6) or UDim2.new(0,160,0,0)
    dropdownFrame:TweenSize(targetSize, Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.25, true)
end)

-- Hide/unhide
hideButton.MouseButton1Click:Connect(function()
    mainFrame.Visible = false
    unhideButton.Visible = true
end)

unhideButton.MouseButton1Click:Connect(function()
    mainFrame.Visible = true
    unhideButton.Visible = false
end)

-- Return camera to local player
returnButton.MouseButton1Click:Connect(function()
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
        workspace.CurrentCamera.CameraSubject = LocalPlayer.Character:FindFirstChild("Humanoid")
    end
end)

-- New message button: scroll to bottom
newMsgButton.MouseButton1Click:Connect(function()
    messageFrame.CanvasPosition = Vector2.new(0, msgLayout.AbsoluteContentSize.Y)
    newMsgButton.Visible = false
end)

-- Filter button handlers
allButton.MouseButton1Click:Connect(function()
    currentFilter = "All"
    renderMessages()
end)
dmButton.MouseButton1Click:Connect(function()
    currentFilter = "DM"
    renderMessages()
end)
meButton.MouseButton1Click:Connect(function()
    currentFilter = "Me"
    renderMessages()
end)
mentionsButton.MouseButton1Click:Connect(function()
    currentFilter = "Mentions"
    renderMessages()
end)
systemButton.MouseButton1Click:Connect(function()
    currentFilter = "System"
    renderMessages()
end)
friendsButton.MouseButton1Click:Connect(function()
    currentFilter = "Friends"
    renderMessages()
end)

-- When local player properties change (display name), rebuild player list to reflect it
LocalPlayer:GetPropertyChangedSignal("DisplayName"):Connect(function()
    rebuildPlayerButtons()
end)

-- Initial print
print("Chat Logger loaded — All features active (DM's, Me, Mentions, System, Friends, whisper notifications).")

-- Expose a small API in case you want to toggle programmatically
gui:SetAttribute("ChatLoggerLoaded", true)

-- Defensive: periodically trim notifications (in case)
spawn(function()
    while gui.Parent do
        task.wait(30)
        -- destroy long-lived notifications if any (they should be auto-removed)
        for _, v in ipairs(notifyContainer:GetChildren()) do
            if v:IsA("Frame") and v:GetAttribute("createdAt") and (tick() - v:GetAttribute("createdAt") > 30) then
                v:Destroy()
            end
        end
    end
end)
